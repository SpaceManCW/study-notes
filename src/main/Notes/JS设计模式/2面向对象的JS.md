## 面向对象的JS

JS与其他面向对象的语言有很多不同的地方，比如没有类式继承，没有在语言层面提供对抽象类和接口的支持等。我们在使用设计模式时更要和传统面向对象语言做对比。所以在学习设计模式之前要了解一些JS在面向对象方面的知识。

#### 1.1动态类型语言和鸭子模式

编程语言按照数据类型大致分两大类：

- 静态类型语言
- 动态类型语言

静态类型语言在编译时已经确定变量类型，静态类型语言则是在程序运行时待变量被赋予某个值后才具有某种类型。

静态类型语言优缺：

优点：

- 在编译时就发现类型不匹配的错误，提前避免一些程序运行时可能发生的错误
- 明确数据类型，编译器可以做一些优化提高程序执行速度

缺点：

- 迫使程序员按照强契约来编写程序
- 类型声明会增加很多代码

动态类型语言优缺点：

优点：

- 代码数量少，看起来简洁，专注于逻辑表达

缺点：

- 无法保证变量类型，运行期可能报错

##### 鸭子类型

动态类型语言对变量类型的宽容给编码带来很多灵活性。无需进行类型检测，可以调用任何对象的任意方法而无需考虑它是否拥有该方法。这一切都建立在**鸭子类型**的概念上。通俗的说就是：“如果它走起来像鸭子，叫起来也是鸭子，那么它就是鸭子”**鸭子类型指导我们只关注对象行为而不关注对象本身**

“面向接口编程”是设计模式中最重要的思想，但是JS中“面向接口编程”的过程和主流的静态类型语言不一样，因此在JS中实现设计模式的过程与其他语言会大相径庭。

#### 1.2多态

多态的实际含义：同一操作作用于不同对象上，可以产生不同的解释和不同的执行结果。而多态背后的思想是将“做什么”和“谁去做以及怎么做”分离开，也就是将“不变的事物”与“可能改变的事物”分离开。多态性的表现是实现众多设计设计模式的目标。要实现多态归根结底要消除类型之间的耦合关系。在Java中可以通过向上转型来实现多态。而JS在运行期间是可变的，这意味着JS对象的多态是与生俱来的。

**多态的好处就在于你不必先清楚类型再调用对象的行为，你可以直接调用该行为，其他的一切由多态机制解决**

将行为分布在各个对象中，并让这些对象各自负责自己的行为，这是面向对象设计的优点。

#### 1.3封装

封装的目的是将信息隐藏。我们讨论的封装包括：封装数据、封装实现、封装类型、封装变化

许多语言提供了private、public、protected等关键字来提供不同访问权限，但是JS没有，只能依赖变量作用域来实现封装特性，而且只能模拟private、public两种。除了ES6提供的let，一般使用函数来创建作用域。封装使对象之间的耦合变得松散，对象之间只通过暴露的API接口通信。

#### 1.4原型模式和基于原型继承的JS对象系统

以类为中心的面向对象语言中，类和对象的关系可以理解为铸模和铸件的关系，对象总是从类中创建来。在原型编程的思想中，类并不是必须的，对象未必需要从类中创建，一个对象通过克隆另一个类所得到。

**原型模式不单是一种设计模式，也被称为一种编程泛型**

##### 使用克隆的原型模式

从设计模式的角度来说，原型模式是用于创建对象的一种模式，原型模式不再关注对象的具体类型，而是找到一个对象然后克隆一个一模一样的对象。使用原型模式只需要调用负责克隆的方法，便能实现同样的功能。原型模式的关键在于语言本谁是否提供了clone方法。ES5提供了Object.create方法，可以用来克隆对象。

**注意：var a = Object.creat(b)实际上是创建一个新对象a,a的原型是b**

JS最初只有一个根对象Object，其他所有对象都克隆自另外一个对象。如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。比如Object对象是Animal对象的原型，而Animal对象是Dog对象的原型，那么当我们尝试调用Dog的某个方法，Dog没有的话就会把请求委托给它的原型对象Animal，依次向上找，这就是原型链，这样一来，依靠原型链就实现了继承，看起来就像是Animal是Dog的父类，Object是Animal的父类。

**基于原型链的委托机制就是原型继承的本质，即当对象无法响应某个请求时就把该请委托给它自己的原型**

事实上JS中的根对象并不是Object而是Object.prototype对象，JS中的每个对象实际上都是从Object.prototype克隆来的，而Object.prototype是一个空对象。无论是字面量创建对象还是new Object()创建对象实际上都是从Object.prototype上克隆一个对象出来。

在JS中函数可以当作普通函数调用，也可以作为构造器来调用。使用new操作符调用函数，此时函数就是一个构造器，用new操作符创建对象的过程实际上也是先从Object.prototype上克隆一个对象然后再做些其他的操作。

值得注意的是我们一直在说对象的原型，而准确的说法应该是对象的构造器的原型。JS给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认指向它构造器的原型对象。那么其实new操作符做的操作就是把由克隆Object.prototype而来的新对象的原型手动操作使其指向其构造函数的原型，这样新对象才能连接上该构造函数的原型链进而继承一些属性。即使ES6带来了新的Class语法，让JS看起来像是一门基于类的编程语言，而实际上背后仍然是原型机制来创建对象。

**设计模式在很多时候其实都体现了语言的不足之处，作为Web前端开发者相信JS在未来很长时间内都是唯一的选择**
